{"version":3,"sources":["webpack:///0.dist/bundle-webpack-lazy-loading.js","webpack:///./node_modules/rxjs/observable/concat.js","webpack:///./node_modules/rxjs/add/operator/mergeMap.js","webpack:///./node_modules/rxjs/add/observable/timer.js","webpack:///./node_modules/rxjs/observable/timer.js","webpack:///./node_modules/rxjs/observable/TimerObservable.js","webpack:///./node_modules/rxjs/util/isNumeric.js","webpack:///./node_modules/rxjs/scheduler/async.js","webpack:///./node_modules/rxjs/scheduler/AsyncAction.js","webpack:///./node_modules/rxjs/scheduler/Action.js","webpack:///./node_modules/rxjs/scheduler/AsyncScheduler.js","webpack:///./node_modules/rxjs/Scheduler.js","webpack:///./node_modules/rxjs/util/isDate.js","webpack:///./node_modules/rxjs/add/observable/forkJoin.js","webpack:///./node_modules/rxjs/add/observable/of.js","webpack:///./node_modules/rxjs/add/operator/take.js","webpack:///./node_modules/rxjs/operator/take.js","webpack:///./node_modules/rxjs/operators/take.js","webpack:///./node_modules/rxjs/add/operator/concat.js","webpack:///./node_modules/rxjs/operator/concat.js","webpack:///./node_modules/rxjs/operators/concat.js","webpack:///./components/rxjs-streams/rxjs-streams.ngfactory.js","webpack:///./components/rxjs-streams/rxjs-streams.ts","webpack:///./app-lazy/lazy-modules/rxjs-streams.module.ts","webpack:///./app-lazy/lazy-modules/rxjs-streams.module.ngfactory.js","webpack:///./node_modules/rxjs/add/operator/map.js","webpack:///./node_modules/rxjs/observable/forkJoin.js","webpack:///./node_modules/rxjs/observable/ForkJoinObservable.js","webpack:///./node_modules/rxjs/add/operator/merge.js","webpack:///./node_modules/rxjs/operator/merge.js","webpack:///./node_modules/rxjs/operators/merge.js"],"names":["webpackJsonp","100","module","exports","__webpack_require__","concat","observables","_i","arguments","length","isScheduler_1","isScheduler","from_1","from","concatAll_1","concatAll","of_1","of","apply","101","Observable_1","mergeMap_1","Observable","prototype","mergeMap","flatMap","108","timer_1","timer","109","TimerObservable_1","TimerObservable","create","110","__extends","this","d","b","__","constructor","p","hasOwnProperty","Object","isNumeric_1","async_1","isDate_1","_super","dueTime","period","scheduler","call","isNumeric","Number","async","isDate","now","initialDelay","dispatch","state","index","subscriber","action","next","closed","complete","schedule","_subscribe","_a","111","val","isArray_1","isArray","parseFloat","112","AsyncAction_1","AsyncScheduler_1","AsyncScheduler","AsyncAction","113","root_1","Action_1","work","pending","delay","id","recycleAsyncId","requestAsyncId","root","setInterval","flush","bind","clearInterval","undefined","execute","Error","error","_execute","errored","errorValue","e","unsubscribe","_unsubscribe","actions","indexOf","splice","Action","114","Subscription_1","Subscription","115","Scheduler_1","active","scheduled","push","shift","Scheduler","116","SchedulerAction","Date","117","value","isNaN","118","forkJoin_1","forkJoin","119","120","take_1","take","121","count","122","source","EmptyObservable_1","EmptyObservable","lift","TakeOperator","Subscriber_1","ArgumentOutOfRangeError_1","total","ArgumentOutOfRangeError","subscribe","TakeSubscriber","destination","_next","Subscriber","123","concat_1","124","concat_2","concatStatic","125","83","__webpack_exports__","View_RxJsStreams_1","_l","rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__","rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_1__angular_common__","klass","ngClass","stream1","stream2","_ck","_v","context","$implicit","View_RxJsStreams_2","View_RxJsStreams_3","View_RxJsStreams_0","en","$event","ad","_co","component","mergeStreams","concatStreams","forkJoinStreams","flatMapStreams","ngForOf","concatStream","mergeStream","forkJoinStream","flatMappedStreams","msg","View_RxJsStreams_Host_0","RenderType_RxJsStreams","RxJsStreams","defineProperty","__WEBPACK_IMPORTED_MODULE_0__angular_core__","__WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__","__WEBPACK_IMPORTED_MODULE_2_rxjs_add_observable_timer__","n","__WEBPACK_IMPORTED_MODULE_3_rxjs_add_observable_forkJoin__","__WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_of__","__WEBPACK_IMPORTED_MODULE_5_rxjs_add_operator_take__","__WEBPACK_IMPORTED_MODULE_6_rxjs_add_operator_merge__","__WEBPACK_IMPORTED_MODULE_7_rxjs_add_operator_concat__","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","i","_this","operand1","res","first","map","second","merge","selector","template","rxjs_streams_module___WEBPACK_IMPORTED_MODULE_0__angular_core__","__WEBPACK_IMPORTED_MODULE_1__angular_common__","__WEBPACK_IMPORTED_MODULE_2__angular_router__","__WEBPACK_IMPORTED_MODULE_4_rxjs_add_operator_map__","__WEBPACK_IMPORTED_MODULE_5_rxjs_add_operator_mergeMap__","rxjs_streams_module___decorate","rxjs_streams_module_RxJsStreamsModule","RxJsStreamsModule","declarations","imports","forChild","path","styles_RxJsStreams","encapsulation","styles","data","RxJsStreamsNgFactory","RxJsStreamsModuleNgFactory","rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__","__WEBPACK_IMPORTED_MODULE_3__angular_common__","__WEBPACK_IMPORTED_MODULE_4__angular_router__","94","map_1","95","ForkJoinObservable_1","ForkJoinObservable","96","subscribeToResult_1","OuterSubscriber_1","sources","resultSelector","pop","ForkJoinSubscriber","completed","haveValues","len","values","Array","innerSubscription","subscribeToResult","outerIndex","add","notifyNext","outerValue","innerValue","innerIndex","innerSub","_hasValue","notifyComplete","OuterSubscriber","97","merge_1","98","merge_2","mergeStatic","99"],"mappings":"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","file":"0.dist/bundle-webpack-lazy-loading.js","sourcesContent":["webpackJsonp([0],{\n\n/***/ 100:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar isScheduler_1 = __webpack_require__(21);\nvar of_1 = __webpack_require__(38);\nvar from_1 = __webpack_require__(41);\nvar concatAll_1 = __webpack_require__(42);\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {\n        return from_1.from(observables[0]);\n    }\n    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ 101:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar mergeMap_1 = __webpack_require__(39);\nObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n/***/ }),\n\n/***/ 108:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar timer_1 = __webpack_require__(109);\nObservable_1.Observable.timer = timer_1.timer;\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n\n/***/ 109:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar TimerObservable_1 = __webpack_require__(110);\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n\n/***/ 110:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(111);\nvar Observable_1 = __webpack_require__(1);\nvar async_1 = __webpack_require__(112);\nvar isScheduler_1 = __webpack_require__(21);\nvar isDate_1 = __webpack_require__(117);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n/***/ }),\n\n/***/ 111:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar isArray_1 = __webpack_require__(18);\nfunction isNumeric(val) {\n    // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    // adding 1 corrects loss of precision from parseFloat (#15100)\n    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\nexports.isNumeric = isNumeric;\n;\n//# sourceMappingURL=isNumeric.js.map\n\n/***/ }),\n\n/***/ 112:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar AsyncAction_1 = __webpack_require__(113);\nvar AsyncScheduler_1 = __webpack_require__(115);\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\nexports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n//# sourceMappingURL=async.js.map\n\n/***/ }),\n\n/***/ 113:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(3);\nvar Action_1 = __webpack_require__(114);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // or the action has been rescheduled before it's executed, clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map\n\n/***/ }),\n\n/***/ 114:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(8);\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        _super.call(this);\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map\n\n/***/ }),\n\n/***/ 115:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = __webpack_require__(116);\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        _super.apply(this, arguments);\n        this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        this.scheduled = undefined;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map\n\n/***/ }),\n\n/***/ 116:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nvar Scheduler = (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map\n\n/***/ }),\n\n/***/ 117:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n/***/ }),\n\n/***/ 118:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar forkJoin_1 = __webpack_require__(95);\nObservable_1.Observable.forkJoin = forkJoin_1.forkJoin;\n//# sourceMappingURL=forkJoin.js.map\n\n/***/ }),\n\n/***/ 119:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar of_1 = __webpack_require__(38);\nObservable_1.Observable.of = of_1.of;\n//# sourceMappingURL=of.js.map\n\n/***/ }),\n\n/***/ 120:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar take_1 = __webpack_require__(121);\nObservable_1.Observable.prototype.take = take_1.take;\n//# sourceMappingURL=take.js.map\n\n/***/ }),\n\n/***/ 121:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar take_1 = __webpack_require__(122);\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n    return take_1.take(count)(this);\n}\nexports.take = take;\n//# sourceMappingURL=take.js.map\n\n/***/ }),\n\n/***/ 122:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(0);\nvar ArgumentOutOfRangeError_1 = __webpack_require__(43);\nvar EmptyObservable_1 = __webpack_require__(10);\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n    return function (source) {\n        if (count === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else {\n            return source.lift(new TakeOperator(count));\n        }\n    };\n}\nexports.take = take;\nvar TakeOperator = (function () {\n    function TakeOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    TakeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeSubscriber(subscriber, this.total));\n    };\n    return TakeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeSubscriber = (function (_super) {\n    __extends(TakeSubscriber, _super);\n    function TakeSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    TakeSubscriber.prototype._next = function (value) {\n        var total = this.total;\n        var count = ++this.count;\n        if (count <= total) {\n            this.destination.next(value);\n            if (count === total) {\n                this.destination.complete();\n                this.unsubscribe();\n            }\n        }\n    };\n    return TakeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=take.js.map\n\n/***/ }),\n\n/***/ 123:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar concat_1 = __webpack_require__(124);\nObservable_1.Observable.prototype.concat = concat_1.concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ 124:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar concat_1 = __webpack_require__(125);\nvar concat_2 = __webpack_require__(100);\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return concat_1.concat.apply(void 0, observables)(this);\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ 125:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar concat_1 = __webpack_require__(100);\nvar concat_2 = __webpack_require__(100);\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ 83:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./components/rxjs-streams/rxjs-streams.ts\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_add_observable_timer__ = __webpack_require__(108);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_add_observable_timer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_add_observable_timer__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_add_observable_forkJoin__ = __webpack_require__(118);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_add_observable_forkJoin___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_add_observable_forkJoin__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_of__ = __webpack_require__(119);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_of__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_add_operator_take__ = __webpack_require__(120);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_add_operator_take___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_add_operator_take__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_add_operator_merge__ = __webpack_require__(97);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_add_operator_merge___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_add_operator_merge__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_add_operator_concat__ = __webpack_require__(123);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_add_operator_concat___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs_add_operator_concat__);\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n\n\n\nvar RxJsStreams = (function () {\n    function RxJsStreams() {\n        this.concatStream = [];\n        this.mergeStream = [];\n        this.forkJoinStream = [];\n        this.flatMappedStreams = {};\n    }\n    RxJsStreams.prototype.flatMapStreams = function () {\n        var _this = this;\n        var first = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__[\"Observable\"].of(10);\n        first.flatMap(function (operand1) {\n            return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__[\"Observable\"].of(operand1 + 10);\n        })\n            .subscribe(function (res) { return _this.flatMappedStreams = { msg: '10 + 10 = ' + res }; });\n    };\n    RxJsStreams.prototype.concatStreams = function () {\n        var _this = this;\n        var first = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__[\"Observable\"].timer(10, 500).map(function (r) {\n            return { source: 1, value: r };\n        }).take(4);\n        var second = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__[\"Observable\"].timer(10, 500).map(function (r) {\n            return { source: 2, value: r };\n        }).take(4);\n        first.concat(second).subscribe(function (res) { return _this.concatStream.push(res); });\n    };\n    RxJsStreams.prototype.mergeStreams = function () {\n        var _this = this;\n        var first = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__[\"Observable\"].timer(10, 500).map(function (r) {\n            return { source: 1, value: r };\n        }).take(4);\n        var second = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__[\"Observable\"].timer(10, 500).map(function (r) {\n            return { source: 2, value: r };\n        }).take(4);\n        first.merge(second).subscribe(function (res) { return _this.mergeStream.push(res); });\n    };\n    RxJsStreams.prototype.forkJoinStreams = function () {\n        var _this = this;\n        var first = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__[\"Observable\"].of({ source: 1, value: 1 });\n        var second = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__[\"Observable\"].of({ source: 2, value: 1 });\n        __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__[\"Observable\"].forkJoin(first, second)\n            .subscribe(function (res) { return _this.forkJoinStream = res; });\n    };\n    RxJsStreams = __decorate([\n        __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"k\" /* Component */]({\n            selector: 'rxjs-streams',\n            template: \"\\n  <div class=\\\"stream1\\\">Stream1</div>\\n  <div class=\\\"stream2\\\">Stream2</div>\\n  <br/>\\n  <button (click)=\\\"mergeStreams()\\\">Merge Streams</button>\\n  <button (click)=\\\"concatStreams()\\\">Concat Streams</button>\\n  <button (click)=\\\"forkJoinStreams()\\\">ForkJoin Streams</button>\\n  <button (click)=\\\"flatMapStreams()\\\">FlatMap Streams</button>\\n\\n  <div class=\\\"stream-section\\\">\\n    <h4>Concatenated Streams</h4>\\n    <div *ngFor=\\\"let item of concatStream\\\">\\n      <div class=\\\"floatLeft\\\" [ngClass]=\\\"{stream1:item.source === 1,stream2:item.source === 2}\\\">{{item.value}}</div>\\n    </div>\\n  </div>\\n\\n  <div class=\\\"stream-section\\\">\\n    <h4>Merged Streams</h4>\\n    <div *ngFor=\\\"let item of mergeStream\\\">\\n      <div class=\\\"floatLeft\\\" [ngClass]=\\\"{stream1:item.source === 1,stream2:item.source === 2}\\\">{{item.value}}</div>\\n    </div>\\n  </div>\\n\\n  <div class=\\\"stream-section\\\">\\n    <h4>ForkJoined Streams</h4>\\n    <div *ngFor=\\\"let item of forkJoinStream\\\">\\n      <div [ngClass]=\\\"{stream1:item.source === 1,stream2:item.source === 2}\\\">{{item.value}}</div>\\n    </div>\\n  </div>\\n\\n  <br/>\\n  <div>\\n    <h4>Flatmapped Streams</h4>\\n    <div>{{flatMappedStreams.msg}}</div>\\n  </div>\\n\"\n        })\n    ], RxJsStreams);\n    return RxJsStreams;\n}());\n\n\n// CONCATENATED MODULE: ./app-lazy/lazy-modules/rxjs-streams.module.ts\n/* harmony import */ var rxjs_streams_module___WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_router__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_add_operator_map__ = __webpack_require__(94);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_add_operator_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_add_operator_map__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_add_operator_mergeMap__ = __webpack_require__(101);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_add_operator_mergeMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_add_operator_mergeMap__);\nvar rxjs_streams_module___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n\nvar rxjs_streams_module_RxJsStreamsModule = (function () {\n    function RxJsStreamsModule() {\n    }\n    RxJsStreamsModule = rxjs_streams_module___decorate([\n        rxjs_streams_module___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"C\" /* NgModule */]({\n            declarations: [RxJsStreams],\n            imports: [\n                __WEBPACK_IMPORTED_MODULE_1__angular_common__[\"c\" /* CommonModule */],\n                __WEBPACK_IMPORTED_MODULE_2__angular_router__[\"m\" /* RouterModule */].forChild([\n                    { path: '', component: RxJsStreams }\n                ])\n            ]\n        })\n    ], RxJsStreamsModule);\n    return RxJsStreamsModule;\n}());\n\n\n// CONCATENATED MODULE: ./components/rxjs-streams/rxjs-streams.ngfactory.js\n/* harmony import */ var rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(2);\n/* harmony import */ var rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(4);\n\n\n\nvar styles_RxJsStreams = [];\nvar RenderType_RxJsStreams = rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_15\" /* ɵcrt */]({ encapsulation: 2, styles: styles_RxJsStreams, data: {} });\n\nfunction View_RxJsStreams_1(_l) { return rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵvid */](0, [(_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](0, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](1, 0, null, null, 3, \"div\", [[\"class\", \"floatLeft\"]], null, null, null, null, null)), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_16\" /* ɵdid */](2, 278528, null, 0, rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_1__angular_common__[\"i\" /* NgClass */], [rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"z\" /* IterableDiffers */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"A\" /* KeyValueDiffers */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"o\" /* ElementRef */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"N\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_33\" /* ɵpod */](3, { stream1: 0, stream2: 1 }), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* ɵted */](4, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_0 = \"floatLeft\"; var currVal_1 = _ck(_v, 3, 0, (_v.context.$implicit.source === 1), (_v.context.$implicit.source === 2)); _ck(_v, 2, 0, currVal_0, currVal_1); }, function (_ck, _v) { var currVal_2 = _v.context.$implicit.value; _ck(_v, 4, 0, currVal_2); }); }\nfunction View_RxJsStreams_2(_l) { return rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵvid */](0, [(_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](0, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](1, 0, null, null, 3, \"div\", [[\"class\", \"floatLeft\"]], null, null, null, null, null)), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_16\" /* ɵdid */](2, 278528, null, 0, rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_1__angular_common__[\"i\" /* NgClass */], [rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"z\" /* IterableDiffers */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"A\" /* KeyValueDiffers */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"o\" /* ElementRef */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"N\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_33\" /* ɵpod */](3, { stream1: 0, stream2: 1 }), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* ɵted */](4, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_0 = \"floatLeft\"; var currVal_1 = _ck(_v, 3, 0, (_v.context.$implicit.source === 1), (_v.context.$implicit.source === 2)); _ck(_v, 2, 0, currVal_0, currVal_1); }, function (_ck, _v) { var currVal_2 = _v.context.$implicit.value; _ck(_v, 4, 0, currVal_2); }); }\nfunction View_RxJsStreams_3(_l) { return rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵvid */](0, [(_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](0, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](1, 0, null, null, 3, \"div\", [], null, null, null, null, null)), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_16\" /* ɵdid */](2, 278528, null, 0, rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_1__angular_common__[\"i\" /* NgClass */], [rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"z\" /* IterableDiffers */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"A\" /* KeyValueDiffers */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"o\" /* ElementRef */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"N\" /* Renderer2 */]], { ngClass: [0, \"ngClass\"] }, null), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_33\" /* ɵpod */](3, { stream1: 0, stream2: 1 }), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* ɵted */](4, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_0 = _ck(_v, 3, 0, (_v.context.$implicit.source === 1), (_v.context.$implicit.source === 2)); _ck(_v, 2, 0, currVal_0); }, function (_ck, _v) { var currVal_1 = _v.context.$implicit.value; _ck(_v, 4, 0, currVal_1); }); }\nfunction View_RxJsStreams_0(_l) { return rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵvid */](0, [(_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](0, 0, null, null, 1, \"div\", [[\"class\", \"stream1\"]], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* ɵted */](-1, null, [\"Stream1\"])), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](2, 0, null, null, 1, \"div\", [[\"class\", \"stream2\"]], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* ɵted */](-1, null, [\"Stream2\"])), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](4, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](5, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.mergeStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* ɵted */](-1, null, [\"Merge Streams\"])), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](7, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.concatStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* ɵted */](-1, null, [\"Concat Streams\"])), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](9, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.forkJoinStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* ɵted */](-1, null, [\"ForkJoin Streams\"])), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](11, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.flatMapStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* ɵted */](-1, null, [\"FlatMap Streams\"])), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](13, 0, null, null, 4, \"div\", [[\"class\", \"stream-section\"]], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](14, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* ɵted */](-1, null, [\"Concatenated Streams\"])), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_12\" /* ɵand */](16777216, null, null, 1, null, View_RxJsStreams_1)), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_16\" /* ɵdid */](17, 802816, null, 0, rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_1__angular_common__[\"j\" /* NgForOf */], [rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_0\" /* ViewContainerRef */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"W\" /* TemplateRef */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"z\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](18, 0, null, null, 4, \"div\", [[\"class\", \"stream-section\"]], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](19, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* ɵted */](-1, null, [\"Merged Streams\"])), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_12\" /* ɵand */](16777216, null, null, 1, null, View_RxJsStreams_2)), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_16\" /* ɵdid */](22, 802816, null, 0, rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_1__angular_common__[\"j\" /* NgForOf */], [rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_0\" /* ViewContainerRef */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"W\" /* TemplateRef */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"z\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](23, 0, null, null, 4, \"div\", [[\"class\", \"stream-section\"]], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](24, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* ɵted */](-1, null, [\"ForkJoined Streams\"])), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_12\" /* ɵand */](16777216, null, null, 1, null, View_RxJsStreams_3)), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_16\" /* ɵdid */](27, 802816, null, 0, rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_1__angular_common__[\"j\" /* NgForOf */], [rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_0\" /* ViewContainerRef */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"W\" /* TemplateRef */], rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"z\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](28, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](29, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](30, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* ɵted */](-1, null, [\"Flatmapped Streams\"])), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](32, 0, null, null, 1, \"div\", [], null, null, null, null, null)), (_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* ɵted */](33, null, [\"\", \"\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.concatStream; _ck(_v, 17, 0, currVal_0); var currVal_1 = _co.mergeStream; _ck(_v, 22, 0, currVal_1); var currVal_2 = _co.forkJoinStream; _ck(_v, 27, 0, currVal_2); }, function (_ck, _v) { var _co = _v.component; var currVal_3 = _co.flatMappedStreams.msg; _ck(_v, 33, 0, currVal_3); }); }\nfunction View_RxJsStreams_Host_0(_l) { return rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵvid */](0, [(_l()(), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */](0, 0, null, null, 1, \"rxjs-streams\", [], null, null, null, View_RxJsStreams_0, RenderType_RxJsStreams)), rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_16\" /* ɵdid */](1, 49152, null, 0, RxJsStreams, [], null, null)], null, null); }\nvar RxJsStreamsNgFactory = rxjs_streams_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_13\" /* ɵccf */](\"rxjs-streams\", RxJsStreams, View_RxJsStreams_Host_0, {}, {}, []);\n\n\n// CONCATENATED MODULE: ./app-lazy/lazy-modules/rxjs-streams.module.ngfactory.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RxJsStreamsModuleNgFactory\", function() { return RxJsStreamsModuleNgFactory; });\n/* harmony import */ var rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_common__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_router__ = __webpack_require__(9);\n\n\n\n\n\n\nvar RxJsStreamsModuleNgFactory = rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_14\" /* ɵcmf */](rxjs_streams_module_RxJsStreamsModule, [], function (_l) { return rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_28\" /* ɵmod */]([rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_29\" /* ɵmpd */](512, rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* ComponentFactoryResolver */], rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_10\" /* ɵCodegenComponentFactoryResolver */], [[8, [RxJsStreamsNgFactory]], [3, rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* ComponentFactoryResolver */]], rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"F\" /* NgModuleRef */]]), rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_29\" /* ɵmpd */](4608, __WEBPACK_IMPORTED_MODULE_3__angular_common__[\"m\" /* NgLocalization */], __WEBPACK_IMPORTED_MODULE_3__angular_common__[\"l\" /* NgLocaleLocalization */], [rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"B\" /* LOCALE_ID */], [2, __WEBPACK_IMPORTED_MODULE_3__angular_common__[\"t\" /* ɵa */]]]), rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_29\" /* ɵmpd */](512, __WEBPACK_IMPORTED_MODULE_3__angular_common__[\"c\" /* CommonModule */], __WEBPACK_IMPORTED_MODULE_3__angular_common__[\"c\" /* CommonModule */], []), rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_29\" /* ɵmpd */](512, __WEBPACK_IMPORTED_MODULE_4__angular_router__[\"m\" /* RouterModule */], __WEBPACK_IMPORTED_MODULE_4__angular_router__[\"m\" /* RouterModule */], [[2, __WEBPACK_IMPORTED_MODULE_4__angular_router__[\"r\" /* ɵa */]], [2, __WEBPACK_IMPORTED_MODULE_4__angular_router__[\"k\" /* Router */]]]), rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_29\" /* ɵmpd */](512, rxjs_streams_module_RxJsStreamsModule, rxjs_streams_module_RxJsStreamsModule, []), rxjs_streams_module_ngfactory___WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_29\" /* ɵmpd */](1024, __WEBPACK_IMPORTED_MODULE_4__angular_router__[\"i\" /* ROUTES */], function () { return [[{ path: \"\", component: RxJsStreams }]]; }, [])]); });\n\n\n\n/***/ }),\n\n/***/ 94:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar map_1 = __webpack_require__(35);\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n\n/***/ }),\n\n/***/ 95:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ForkJoinObservable_1 = __webpack_require__(96);\nexports.forkJoin = ForkJoinObservable_1.ForkJoinObservable.create;\n//# sourceMappingURL=forkJoin.js.map\n\n/***/ }),\n\n/***/ 96:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(1);\nvar EmptyObservable_1 = __webpack_require__(10);\nvar isArray_1 = __webpack_require__(18);\nvar subscribeToResult_1 = __webpack_require__(19);\nvar OuterSubscriber_1 = __webpack_require__(20);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ForkJoinObservable = (function (_super) {\n    __extends(ForkJoinObservable, _super);\n    function ForkJoinObservable(sources, resultSelector) {\n        _super.call(this);\n        this.sources = sources;\n        this.resultSelector = resultSelector;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Joins last values emitted by passed Observables.\n     *\n     * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n     *\n     * <img src=\"./img/forkJoin.png\" width=\"100%\">\n     *\n     * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n     * or directly as arguments. If no input Observables are provided, resulting stream will complete\n     * immediately.\n     *\n     * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n     * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n     * array will have `n` values, where first value is the last thing emitted by the first Observable,\n     * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n     * not emit more than once and it will complete after that. If you need to emit combined values not only\n     * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n     * or {@link zip} instead.\n     *\n     * In order for resulting array to have the same length as the number of input Observables, whenever any of\n     * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n     * and it will not emit anything either, even if it already has some last values from other Observables.\n     * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n     * unless at any point some other Observable completes without emitting value, which brings us back to\n     * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n     * have to emit something at least once and complete.\n     *\n     * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n     * will be immediately unsubscribed.\n     *\n     * Optionally `forkJoin` accepts project function, that will be called with values which normally\n     * would land in emitted array. Whatever is returned by project function, will appear in output\n     * Observable instead. This means that default project can be thought of as a function that takes\n     * all its arguments and puts them into an array. Note that project function will be called only\n     * when output Observable is supposed to emit a result.\n     *\n     * @example <caption>Use forkJoin with operator emitting immediately</caption>\n     * const observable = Rx.Observable.forkJoin(\n     *   Rx.Observable.of(1, 2, 3, 4),\n     *   Rx.Observable.of(5, 6, 7, 8)\n     * );\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('This is how it ends!')\n     * );\n     *\n     * // Logs:\n     * // [4, 8]\n     * // \"This is how it ends!\"\n     *\n     *\n     * @example <caption>Use forkJoin with operator emitting after some time</caption>\n     * const observable = Rx.Observable.forkJoin(\n     *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n     *   Rx.Observable.interval(500).take(4) // emit 0, 1, 2, 3 every half a second and complete\n     * );\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('This is how it ends!')\n     * );\n     *\n     * // Logs:\n     * // [2, 3] after 3 seconds\n     * // \"This is how it ends!\" immediately after\n     *\n     *\n     * @example <caption>Use forkJoin with project function</caption>\n     * const observable = Rx.Observable.forkJoin(\n     *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n     *   Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\n     *   (n, m) => n + m\n     * );\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('This is how it ends!')\n     * );\n     *\n     * // Logs:\n     * // 5 after 3 seconds\n     * // \"This is how it ends!\" immediately after\n     *\n     * @see {@link combineLatest}\n     * @see {@link zip}\n     *\n     * @param {...SubscribableOrPromise} sources Any number of Observables provided either as an array or as an arguments\n     * passed directly to the operator.\n     * @param {function} [project] Function that takes values emitted by input Observables and returns value\n     * that will appear in resulting Observable instead of default array.\n     * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n     * or value from project function.\n     * @static true\n     * @name forkJoin\n     * @owner Observable\n     */\n    ForkJoinObservable.create = function () {\n        var sources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            sources[_i - 0] = arguments[_i];\n        }\n        if (sources === null || arguments.length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        var resultSelector = null;\n        if (typeof sources[sources.length - 1] === 'function') {\n            resultSelector = sources.pop();\n        }\n        // if the first and only other argument besides the resultSelector is an array\n        // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\n        if (sources.length === 1 && isArray_1.isArray(sources[0])) {\n            sources = sources[0];\n        }\n        if (sources.length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        return new ForkJoinObservable(sources, resultSelector);\n    };\n    ForkJoinObservable.prototype._subscribe = function (subscriber) {\n        return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\n    };\n    return ForkJoinObservable;\n}(Observable_1.Observable));\nexports.ForkJoinObservable = ForkJoinObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ForkJoinSubscriber = (function (_super) {\n    __extends(ForkJoinSubscriber, _super);\n    function ForkJoinSubscriber(destination, sources, resultSelector) {\n        _super.call(this, destination);\n        this.sources = sources;\n        this.resultSelector = resultSelector;\n        this.completed = 0;\n        this.haveValues = 0;\n        var len = sources.length;\n        this.total = len;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            var source = sources[i];\n            var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);\n            if (innerSubscription) {\n                innerSubscription.outerIndex = i;\n                this.add(innerSubscription);\n            }\n        }\n    }\n    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        if (!innerSub._hasValue) {\n            innerSub._hasValue = true;\n            this.haveValues++;\n        }\n    };\n    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\n        var destination = this.destination;\n        var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;\n        var len = values.length;\n        if (!innerSub._hasValue) {\n            destination.complete();\n            return;\n        }\n        this.completed++;\n        if (this.completed !== len) {\n            return;\n        }\n        if (haveValues === len) {\n            var value = resultSelector ? resultSelector.apply(this, values) : values;\n            destination.next(value);\n        }\n        destination.complete();\n    };\n    return ForkJoinSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=ForkJoinObservable.js.map\n\n/***/ }),\n\n/***/ 97:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar merge_1 = __webpack_require__(98);\nObservable_1.Observable.prototype.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n/***/ }),\n\n/***/ 98:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar merge_1 = __webpack_require__(99);\nvar merge_2 = __webpack_require__(36);\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return merge_1.merge.apply(void 0, observables)(this);\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n/***/ }),\n\n/***/ 99:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar merge_1 = __webpack_require__(36);\nvar merge_2 = __webpack_require__(36);\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 0.dist/bundle-webpack-lazy-loading.js","\"use strict\";\nvar isScheduler_1 = require('../util/isScheduler');\nvar of_1 = require('./of');\nvar from_1 = require('./from');\nvar concatAll_1 = require('../operators/concatAll');\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {\n        return from_1.from(observables[0]);\n    }\n    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/concat.js\n// module id = 100\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar mergeMap_1 = require('../../operator/mergeMap');\nObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/mergeMap.js\n// module id = 101\n// module chunks = 0 1","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar timer_1 = require('../../observable/timer');\nObservable_1.Observable.timer = timer_1.timer;\n//# sourceMappingURL=timer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/observable/timer.js\n// module id = 108\n// module chunks = 0","\"use strict\";\nvar TimerObservable_1 = require('./TimerObservable');\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/timer.js\n// module id = 109\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = require('../util/isNumeric');\nvar Observable_1 = require('../Observable');\nvar async_1 = require('../scheduler/async');\nvar isScheduler_1 = require('../util/isScheduler');\nvar isDate_1 = require('../util/isDate');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/TimerObservable.js\n// module id = 110\n// module chunks = 0","\"use strict\";\nvar isArray_1 = require('../util/isArray');\nfunction isNumeric(val) {\n    // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    // adding 1 corrects loss of precision from parseFloat (#15100)\n    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\nexports.isNumeric = isNumeric;\n;\n//# sourceMappingURL=isNumeric.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/isNumeric.js\n// module id = 111\n// module chunks = 0","\"use strict\";\nvar AsyncAction_1 = require('./AsyncAction');\nvar AsyncScheduler_1 = require('./AsyncScheduler');\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\nexports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n//# sourceMappingURL=async.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/async.js\n// module id = 112\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Action_1 = require('./Action');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // or the action has been rescheduled before it's executed, clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/AsyncAction.js\n// module id = 113\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('../Subscription');\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        _super.call(this);\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/Action.js\n// module id = 114\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = require('../Scheduler');\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        _super.apply(this, arguments);\n        this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        this.scheduled = undefined;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/AsyncScheduler.js\n// module id = 115\n// module chunks = 0","\"use strict\";\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nvar Scheduler = (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/Scheduler.js\n// module id = 116\n// module chunks = 0","\"use strict\";\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/isDate.js\n// module id = 117\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar forkJoin_1 = require('../../observable/forkJoin');\nObservable_1.Observable.forkJoin = forkJoin_1.forkJoin;\n//# sourceMappingURL=forkJoin.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/observable/forkJoin.js\n// module id = 118\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar of_1 = require('../../observable/of');\nObservable_1.Observable.of = of_1.of;\n//# sourceMappingURL=of.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/observable/of.js\n// module id = 119\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar take_1 = require('../../operator/take');\nObservable_1.Observable.prototype.take = take_1.take;\n//# sourceMappingURL=take.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/take.js\n// module id = 120\n// module chunks = 0","\"use strict\";\nvar take_1 = require('../operators/take');\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n    return take_1.take(count)(this);\n}\nexports.take = take;\n//# sourceMappingURL=take.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/take.js\n// module id = 121\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n    return function (source) {\n        if (count === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else {\n            return source.lift(new TakeOperator(count));\n        }\n    };\n}\nexports.take = take;\nvar TakeOperator = (function () {\n    function TakeOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    TakeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeSubscriber(subscriber, this.total));\n    };\n    return TakeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeSubscriber = (function (_super) {\n    __extends(TakeSubscriber, _super);\n    function TakeSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    TakeSubscriber.prototype._next = function (value) {\n        var total = this.total;\n        var count = ++this.count;\n        if (count <= total) {\n            this.destination.next(value);\n            if (count === total) {\n                this.destination.complete();\n                this.unsubscribe();\n            }\n        }\n    };\n    return TakeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=take.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/take.js\n// module id = 122\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar concat_1 = require('../../operator/concat');\nObservable_1.Observable.prototype.concat = concat_1.concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/concat.js\n// module id = 123\n// module chunks = 0","\"use strict\";\nvar concat_1 = require('../operators/concat');\nvar concat_2 = require('../observable/concat');\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return concat_1.concat.apply(void 0, observables)(this);\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/concat.js\n// module id = 124\n// module chunks = 0","\"use strict\";\nvar concat_1 = require('../observable/concat');\nvar concat_2 = require('../observable/concat');\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/concat.js\n// module id = 125\n// module chunks = 0","import * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"./rxjs-streams\";\nvar styles_RxJsStreams = [];\nvar RenderType_RxJsStreams = i0.ɵcrt({ encapsulation: 2, styles: styles_RxJsStreams, data: {} });\nexport { RenderType_RxJsStreams as RenderType_RxJsStreams };\nfunction View_RxJsStreams_1(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), i0.ɵeld(1, 0, null, null, 3, \"div\", [[\"class\", \"floatLeft\"]], null, null, null, null, null)), i0.ɵdid(2, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.ɵpod(3, { stream1: 0, stream2: 1 }), (_l()(), i0.ɵted(4, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_0 = \"floatLeft\"; var currVal_1 = _ck(_v, 3, 0, (_v.context.$implicit.source === 1), (_v.context.$implicit.source === 2)); _ck(_v, 2, 0, currVal_0, currVal_1); }, function (_ck, _v) { var currVal_2 = _v.context.$implicit.value; _ck(_v, 4, 0, currVal_2); }); }\nfunction View_RxJsStreams_2(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), i0.ɵeld(1, 0, null, null, 3, \"div\", [[\"class\", \"floatLeft\"]], null, null, null, null, null)), i0.ɵdid(2, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.ɵpod(3, { stream1: 0, stream2: 1 }), (_l()(), i0.ɵted(4, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_0 = \"floatLeft\"; var currVal_1 = _ck(_v, 3, 0, (_v.context.$implicit.source === 1), (_v.context.$implicit.source === 2)); _ck(_v, 2, 0, currVal_0, currVal_1); }, function (_ck, _v) { var currVal_2 = _v.context.$implicit.value; _ck(_v, 4, 0, currVal_2); }); }\nfunction View_RxJsStreams_3(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), i0.ɵeld(1, 0, null, null, 3, \"div\", [], null, null, null, null, null)), i0.ɵdid(2, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { ngClass: [0, \"ngClass\"] }, null), i0.ɵpod(3, { stream1: 0, stream2: 1 }), (_l()(), i0.ɵted(4, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_0 = _ck(_v, 3, 0, (_v.context.$implicit.source === 1), (_v.context.$implicit.source === 2)); _ck(_v, 2, 0, currVal_0); }, function (_ck, _v) { var currVal_1 = _v.context.$implicit.value; _ck(_v, 4, 0, currVal_1); }); }\nexport function View_RxJsStreams_0(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"div\", [[\"class\", \"stream1\"]], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"Stream1\"])), (_l()(), i0.ɵeld(2, 0, null, null, 1, \"div\", [[\"class\", \"stream2\"]], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"Stream2\"])), (_l()(), i0.ɵeld(4, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), i0.ɵeld(5, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.mergeStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ɵted(-1, null, [\"Merge Streams\"])), (_l()(), i0.ɵeld(7, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.concatStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ɵted(-1, null, [\"Concat Streams\"])), (_l()(), i0.ɵeld(9, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.forkJoinStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ɵted(-1, null, [\"ForkJoin Streams\"])), (_l()(), i0.ɵeld(11, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.flatMapStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ɵted(-1, null, [\"FlatMap Streams\"])), (_l()(), i0.ɵeld(13, 0, null, null, 4, \"div\", [[\"class\", \"stream-section\"]], null, null, null, null, null)), (_l()(), i0.ɵeld(14, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"Concatenated Streams\"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_RxJsStreams_1)), i0.ɵdid(17, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ɵeld(18, 0, null, null, 4, \"div\", [[\"class\", \"stream-section\"]], null, null, null, null, null)), (_l()(), i0.ɵeld(19, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"Merged Streams\"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_RxJsStreams_2)), i0.ɵdid(22, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ɵeld(23, 0, null, null, 4, \"div\", [[\"class\", \"stream-section\"]], null, null, null, null, null)), (_l()(), i0.ɵeld(24, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"ForkJoined Streams\"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_RxJsStreams_3)), i0.ɵdid(27, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ɵeld(28, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), i0.ɵeld(29, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), i0.ɵeld(30, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"Flatmapped Streams\"])), (_l()(), i0.ɵeld(32, 0, null, null, 1, \"div\", [], null, null, null, null, null)), (_l()(), i0.ɵted(33, null, [\"\", \"\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.concatStream; _ck(_v, 17, 0, currVal_0); var currVal_1 = _co.mergeStream; _ck(_v, 22, 0, currVal_1); var currVal_2 = _co.forkJoinStream; _ck(_v, 27, 0, currVal_2); }, function (_ck, _v) { var _co = _v.component; var currVal_3 = _co.flatMappedStreams.msg; _ck(_v, 33, 0, currVal_3); }); }\nexport function View_RxJsStreams_Host_0(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"rxjs-streams\", [], null, null, null, View_RxJsStreams_0, RenderType_RxJsStreams)), i0.ɵdid(1, 49152, null, 0, i2.RxJsStreams, [], null, null)], null, null); }\nvar RxJsStreamsNgFactory = i0.ɵccf(\"rxjs-streams\", i2.RxJsStreams, View_RxJsStreams_Host_0, {}, {}, []);\nexport { RxJsStreamsNgFactory as RxJsStreamsNgFactory };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/rxjs-streams/rxjs-streams.ngfactory.js\n// module id = null\n// module chunks = ","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Component } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/observable/timer';\nimport 'rxjs/add/observable/forkJoin';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/operator/take';\nimport 'rxjs/add/operator/merge';\nimport 'rxjs/add/operator/concat';\nvar RxJsStreams = (function () {\n    function RxJsStreams() {\n        this.concatStream = [];\n        this.mergeStream = [];\n        this.forkJoinStream = [];\n        this.flatMappedStreams = {};\n    }\n    RxJsStreams.prototype.flatMapStreams = function () {\n        var _this = this;\n        var first = Observable.of(10);\n        first.flatMap(function (operand1) {\n            return Observable.of(operand1 + 10);\n        })\n            .subscribe(function (res) { return _this.flatMappedStreams = { msg: '10 + 10 = ' + res }; });\n    };\n    RxJsStreams.prototype.concatStreams = function () {\n        var _this = this;\n        var first = Observable.timer(10, 500).map(function (r) {\n            return { source: 1, value: r };\n        }).take(4);\n        var second = Observable.timer(10, 500).map(function (r) {\n            return { source: 2, value: r };\n        }).take(4);\n        first.concat(second).subscribe(function (res) { return _this.concatStream.push(res); });\n    };\n    RxJsStreams.prototype.mergeStreams = function () {\n        var _this = this;\n        var first = Observable.timer(10, 500).map(function (r) {\n            return { source: 1, value: r };\n        }).take(4);\n        var second = Observable.timer(10, 500).map(function (r) {\n            return { source: 2, value: r };\n        }).take(4);\n        first.merge(second).subscribe(function (res) { return _this.mergeStream.push(res); });\n    };\n    RxJsStreams.prototype.forkJoinStreams = function () {\n        var _this = this;\n        var first = Observable.of({ source: 1, value: 1 });\n        var second = Observable.of({ source: 2, value: 1 });\n        Observable.forkJoin(first, second)\n            .subscribe(function (res) { return _this.forkJoinStream = res; });\n    };\n    RxJsStreams = __decorate([\n        Component({\n            selector: 'rxjs-streams',\n            template: \"\\n  <div class=\\\"stream1\\\">Stream1</div>\\n  <div class=\\\"stream2\\\">Stream2</div>\\n  <br/>\\n  <button (click)=\\\"mergeStreams()\\\">Merge Streams</button>\\n  <button (click)=\\\"concatStreams()\\\">Concat Streams</button>\\n  <button (click)=\\\"forkJoinStreams()\\\">ForkJoin Streams</button>\\n  <button (click)=\\\"flatMapStreams()\\\">FlatMap Streams</button>\\n\\n  <div class=\\\"stream-section\\\">\\n    <h4>Concatenated Streams</h4>\\n    <div *ngFor=\\\"let item of concatStream\\\">\\n      <div class=\\\"floatLeft\\\" [ngClass]=\\\"{stream1:item.source === 1,stream2:item.source === 2}\\\">{{item.value}}</div>\\n    </div>\\n  </div>\\n\\n  <div class=\\\"stream-section\\\">\\n    <h4>Merged Streams</h4>\\n    <div *ngFor=\\\"let item of mergeStream\\\">\\n      <div class=\\\"floatLeft\\\" [ngClass]=\\\"{stream1:item.source === 1,stream2:item.source === 2}\\\">{{item.value}}</div>\\n    </div>\\n  </div>\\n\\n  <div class=\\\"stream-section\\\">\\n    <h4>ForkJoined Streams</h4>\\n    <div *ngFor=\\\"let item of forkJoinStream\\\">\\n      <div [ngClass]=\\\"{stream1:item.source === 1,stream2:item.source === 2}\\\">{{item.value}}</div>\\n    </div>\\n  </div>\\n\\n  <br/>\\n  <div>\\n    <h4>Flatmapped Streams</h4>\\n    <div>{{flatMappedStreams.msg}}</div>\\n  </div>\\n\"\n        })\n    ], RxJsStreams);\n    return RxJsStreams;\n}());\nexport { RxJsStreams };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/rxjs-streams/rxjs-streams.ts\n// module id = null\n// module chunks = ","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\nimport { RxJsStreams } from '../../components/rxjs-streams/rxjs-streams';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/mergeMap';\nvar RxJsStreamsModule = (function () {\n    function RxJsStreamsModule() {\n    }\n    RxJsStreamsModule = __decorate([\n        NgModule({\n            declarations: [RxJsStreams],\n            imports: [\n                CommonModule,\n                RouterModule.forChild([\n                    { path: '', component: RxJsStreams }\n                ])\n            ]\n        })\n    ], RxJsStreamsModule);\n    return RxJsStreamsModule;\n}());\nexport { RxJsStreamsModule };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app-lazy/lazy-modules/rxjs-streams.module.ts\n// module id = null\n// module chunks = ","import * as i0 from \"@angular/core\";\nimport * as i1 from \"./rxjs-streams.module\";\nimport * as i2 from \"../../components/rxjs-streams/rxjs-streams.ngfactory\";\nimport * as i3 from \"@angular/common\";\nimport * as i4 from \"@angular/router\";\nimport * as i5 from \"../../components/rxjs-streams/rxjs-streams\";\nvar RxJsStreamsModuleNgFactory = i0.ɵcmf(i1.RxJsStreamsModule, [], function (_l) { return i0.ɵmod([i0.ɵmpd(512, i0.ComponentFactoryResolver, i0.ɵCodegenComponentFactoryResolver, [[8, [i2.RxJsStreamsNgFactory]], [3, i0.ComponentFactoryResolver], i0.NgModuleRef]), i0.ɵmpd(4608, i3.NgLocalization, i3.NgLocaleLocalization, [i0.LOCALE_ID, [2, i3.ɵa]]), i0.ɵmpd(512, i3.CommonModule, i3.CommonModule, []), i0.ɵmpd(512, i4.RouterModule, i4.RouterModule, [[2, i4.ɵa], [2, i4.Router]]), i0.ɵmpd(512, i1.RxJsStreamsModule, i1.RxJsStreamsModule, []), i0.ɵmpd(1024, i4.ROUTES, function () { return [[{ path: \"\", component: i5.RxJsStreams }]]; }, [])]); });\nexport { RxJsStreamsModuleNgFactory as RxJsStreamsModuleNgFactory };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app-lazy/lazy-modules/rxjs-streams.module.ngfactory.js\n// module id = null\n// module chunks = ","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar map_1 = require('../../operator/map');\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/map.js\n// module id = 94\n// module chunks = 0 1 3 4 8","\"use strict\";\nvar ForkJoinObservable_1 = require('./ForkJoinObservable');\nexports.forkJoin = ForkJoinObservable_1.ForkJoinObservable.create;\n//# sourceMappingURL=forkJoin.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/forkJoin.js\n// module id = 95\n// module chunks = 0 3 5 6 7","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar EmptyObservable_1 = require('./EmptyObservable');\nvar isArray_1 = require('../util/isArray');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ForkJoinObservable = (function (_super) {\n    __extends(ForkJoinObservable, _super);\n    function ForkJoinObservable(sources, resultSelector) {\n        _super.call(this);\n        this.sources = sources;\n        this.resultSelector = resultSelector;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Joins last values emitted by passed Observables.\n     *\n     * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n     *\n     * <img src=\"./img/forkJoin.png\" width=\"100%\">\n     *\n     * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n     * or directly as arguments. If no input Observables are provided, resulting stream will complete\n     * immediately.\n     *\n     * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n     * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n     * array will have `n` values, where first value is the last thing emitted by the first Observable,\n     * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n     * not emit more than once and it will complete after that. If you need to emit combined values not only\n     * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n     * or {@link zip} instead.\n     *\n     * In order for resulting array to have the same length as the number of input Observables, whenever any of\n     * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n     * and it will not emit anything either, even if it already has some last values from other Observables.\n     * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n     * unless at any point some other Observable completes without emitting value, which brings us back to\n     * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n     * have to emit something at least once and complete.\n     *\n     * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n     * will be immediately unsubscribed.\n     *\n     * Optionally `forkJoin` accepts project function, that will be called with values which normally\n     * would land in emitted array. Whatever is returned by project function, will appear in output\n     * Observable instead. This means that default project can be thought of as a function that takes\n     * all its arguments and puts them into an array. Note that project function will be called only\n     * when output Observable is supposed to emit a result.\n     *\n     * @example <caption>Use forkJoin with operator emitting immediately</caption>\n     * const observable = Rx.Observable.forkJoin(\n     *   Rx.Observable.of(1, 2, 3, 4),\n     *   Rx.Observable.of(5, 6, 7, 8)\n     * );\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('This is how it ends!')\n     * );\n     *\n     * // Logs:\n     * // [4, 8]\n     * // \"This is how it ends!\"\n     *\n     *\n     * @example <caption>Use forkJoin with operator emitting after some time</caption>\n     * const observable = Rx.Observable.forkJoin(\n     *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n     *   Rx.Observable.interval(500).take(4) // emit 0, 1, 2, 3 every half a second and complete\n     * );\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('This is how it ends!')\n     * );\n     *\n     * // Logs:\n     * // [2, 3] after 3 seconds\n     * // \"This is how it ends!\" immediately after\n     *\n     *\n     * @example <caption>Use forkJoin with project function</caption>\n     * const observable = Rx.Observable.forkJoin(\n     *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n     *   Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\n     *   (n, m) => n + m\n     * );\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('This is how it ends!')\n     * );\n     *\n     * // Logs:\n     * // 5 after 3 seconds\n     * // \"This is how it ends!\" immediately after\n     *\n     * @see {@link combineLatest}\n     * @see {@link zip}\n     *\n     * @param {...SubscribableOrPromise} sources Any number of Observables provided either as an array or as an arguments\n     * passed directly to the operator.\n     * @param {function} [project] Function that takes values emitted by input Observables and returns value\n     * that will appear in resulting Observable instead of default array.\n     * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n     * or value from project function.\n     * @static true\n     * @name forkJoin\n     * @owner Observable\n     */\n    ForkJoinObservable.create = function () {\n        var sources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            sources[_i - 0] = arguments[_i];\n        }\n        if (sources === null || arguments.length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        var resultSelector = null;\n        if (typeof sources[sources.length - 1] === 'function') {\n            resultSelector = sources.pop();\n        }\n        // if the first and only other argument besides the resultSelector is an array\n        // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\n        if (sources.length === 1 && isArray_1.isArray(sources[0])) {\n            sources = sources[0];\n        }\n        if (sources.length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        return new ForkJoinObservable(sources, resultSelector);\n    };\n    ForkJoinObservable.prototype._subscribe = function (subscriber) {\n        return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\n    };\n    return ForkJoinObservable;\n}(Observable_1.Observable));\nexports.ForkJoinObservable = ForkJoinObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ForkJoinSubscriber = (function (_super) {\n    __extends(ForkJoinSubscriber, _super);\n    function ForkJoinSubscriber(destination, sources, resultSelector) {\n        _super.call(this, destination);\n        this.sources = sources;\n        this.resultSelector = resultSelector;\n        this.completed = 0;\n        this.haveValues = 0;\n        var len = sources.length;\n        this.total = len;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            var source = sources[i];\n            var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);\n            if (innerSubscription) {\n                innerSubscription.outerIndex = i;\n                this.add(innerSubscription);\n            }\n        }\n    }\n    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        if (!innerSub._hasValue) {\n            innerSub._hasValue = true;\n            this.haveValues++;\n        }\n    };\n    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\n        var destination = this.destination;\n        var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;\n        var len = values.length;\n        if (!innerSub._hasValue) {\n            destination.complete();\n            return;\n        }\n        this.completed++;\n        if (this.completed !== len) {\n            return;\n        }\n        if (haveValues === len) {\n            var value = resultSelector ? resultSelector.apply(this, values) : values;\n            destination.next(value);\n        }\n        destination.complete();\n    };\n    return ForkJoinSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=ForkJoinObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/ForkJoinObservable.js\n// module id = 96\n// module chunks = 0 3 5 6 7","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar merge_1 = require('../../operator/merge');\nObservable_1.Observable.prototype.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/merge.js\n// module id = 97\n// module chunks = 0 1","\"use strict\";\nvar merge_1 = require('../operators/merge');\nvar merge_2 = require('../observable/merge');\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return merge_1.merge.apply(void 0, observables)(this);\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/merge.js\n// module id = 98\n// module chunks = 0 1","\"use strict\";\nvar merge_1 = require('../observable/merge');\nvar merge_2 = require('../observable/merge');\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/merge.js\n// module id = 99\n// module chunks = 0 1"],"sourceRoot":""}