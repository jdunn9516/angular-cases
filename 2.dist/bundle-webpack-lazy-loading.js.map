{"version":3,"sources":["webpack:///2.dist/bundle-webpack-lazy-loading.js","webpack:///./node_modules/rxjs/add/operator/bufferCount.js","webpack:///./node_modules/rxjs/operator/bufferCount.js","webpack:///./node_modules/rxjs/operators/bufferCount.js","webpack:///./node_modules/rxjs/add/operator/do.js","webpack:///./node_modules/rxjs/operator/do.js","webpack:///./node_modules/rxjs/operators/tap.js","webpack:///./components/rxjs-buffering/rxjs-buffering.ngfactory.js","webpack:///./app-lazy/lazy-modules/rxjs-buffering.module.ts","webpack:///./components/rxjs-buffering/rxjs-buffering.ts","webpack:///./app-lazy/lazy-modules/rxjs-buffering.module.ngfactory.js"],"names":["webpackJsonp","102","module","exports","__webpack_require__","Observable_1","bufferCount_1","Observable","prototype","bufferCount","103","bufferSize","startBufferEvery","this","104","source","lift","BufferCountOperator","__extends","d","b","__","constructor","p","hasOwnProperty","Object","create","Subscriber_1","subscriberClass","BufferSkipCountSubscriber","BufferCountSubscriber","call","subscriber","subscribe","_super","destination","buffer","_next","value","push","length","next","_complete","Subscriber","buffers","count","_a","i","splice","shift","105","do_1","do","_do","106","nextOrObserver","error","complete","tap_1","tap","107","DoOperator","DoSubscriber","safeSubscriber","syncErrorThrowable","add","syncErrorThrown","syncErrorValue","_error","err","87","__webpack_exports__","View_RxJsBuffering_1","_l","core","_v","en","$event","ad","_co","component","context","$implicit","_ck","View_RxJsBuffering_2","calculation","sum","View_RxJsBuffering_0","common","ngForOf","ngIf","numbers","showSum","View_RxJsBuffering_Host_0","RenderType_RxJsBuffering","rxjs_buffering_RxJsBuffering","defineProperty","RxJsBufferingModule","Subject","RxJsBuffering","number","ngOnInit","_this","series","asObservable","a","res","reduce","styles_RxJsBuffering","encapsulation","styles","data","RxJsBufferingNgFactory","router","RxJsBufferingModuleNgFactory","path"],"mappings":"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","file":"2.dist/bundle-webpack-lazy-loading.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 102:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar bufferCount_1 = __webpack_require__(103);\nObservable_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount;\n//# sourceMappingURL=bufferCount.js.map\n\n/***/ }),\n\n/***/ 103:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar bufferCount_1 = __webpack_require__(104);\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) { startBufferEvery = null; }\n    return bufferCount_1.bufferCount(bufferSize, startBufferEvery)(this);\n}\nexports.bufferCount = bufferCount;\n//# sourceMappingURL=bufferCount.js.map\n\n/***/ }),\n\n/***/ 104:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(0);\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) { startBufferEvery = null; }\n    return function bufferCountOperatorFunction(source) {\n        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n    };\n}\nexports.bufferCount = bufferCount;\nvar BufferCountOperator = (function () {\n    function BufferCountOperator(bufferSize, startBufferEvery) {\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        if (!startBufferEvery || bufferSize === startBufferEvery) {\n            this.subscriberClass = BufferCountSubscriber;\n        }\n        else {\n            this.subscriberClass = BufferSkipCountSubscriber;\n        }\n    }\n    BufferCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n    };\n    return BufferCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferCountSubscriber = (function (_super) {\n    __extends(BufferCountSubscriber, _super);\n    function BufferCountSubscriber(destination, bufferSize) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.buffer = [];\n    }\n    BufferCountSubscriber.prototype._next = function (value) {\n        var buffer = this.buffer;\n        buffer.push(value);\n        if (buffer.length == this.bufferSize) {\n            this.destination.next(buffer);\n            this.buffer = [];\n        }\n    };\n    BufferCountSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer.length > 0) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferCountSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSkipCountSubscriber = (function (_super) {\n    __extends(BufferSkipCountSubscriber, _super);\n    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        this.buffers = [];\n        this.count = 0;\n    }\n    BufferSkipCountSubscriber.prototype._next = function (value) {\n        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;\n        this.count++;\n        if (count % startBufferEvery === 0) {\n            buffers.push([]);\n        }\n        for (var i = buffers.length; i--;) {\n            var buffer = buffers[i];\n            buffer.push(value);\n            if (buffer.length === bufferSize) {\n                buffers.splice(i, 1);\n                this.destination.next(buffer);\n            }\n        }\n    };\n    BufferSkipCountSubscriber.prototype._complete = function () {\n        var _a = this, buffers = _a.buffers, destination = _a.destination;\n        while (buffers.length > 0) {\n            var buffer = buffers.shift();\n            if (buffer.length > 0) {\n                destination.next(buffer);\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferSkipCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=bufferCount.js.map\n\n/***/ }),\n\n/***/ 105:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar do_1 = __webpack_require__(106);\nObservable_1.Observable.prototype.do = do_1._do;\nObservable_1.Observable.prototype._do = do_1._do;\n//# sourceMappingURL=do.js.map\n\n/***/ }),\n\n/***/ 106:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar tap_1 = __webpack_require__(107);\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\nfunction _do(nextOrObserver, error, complete) {\n    return tap_1.tap(nextOrObserver, error, complete)(this);\n}\nexports._do = _do;\n//# sourceMappingURL=do.js.map\n\n/***/ }),\n\n/***/ 107:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(0);\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nfunction tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nexports.tap = tap;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=tap.js.map\n\n/***/ }),\n\n/***/ 87:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js\nvar core = __webpack_require__(3);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/do.js\nvar operator_do = __webpack_require__(105);\nvar do_default = /*#__PURE__*/__webpack_require__.n(operator_do);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/bufferCount.js\nvar bufferCount = __webpack_require__(102);\nvar bufferCount_default = /*#__PURE__*/__webpack_require__.n(bufferCount);\n\n// CONCATENATED MODULE: ./app-lazy/lazy-modules/rxjs-buffering.module.ts\n\n\nvar RxJsBufferingModule = (function () {\n    function RxJsBufferingModule() {\n    }\n    return RxJsBufferingModule;\n}());\n\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/esm5/common.js\nvar common = __webpack_require__(4);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Subject.js\nvar Subject = __webpack_require__(5);\nvar Subject_default = /*#__PURE__*/__webpack_require__.n(Subject);\n\n// CONCATENATED MODULE: ./components/rxjs-buffering/rxjs-buffering.ts\n\nvar rxjs_buffering_RxJsBuffering = (function () {\n    function RxJsBuffering() {\n        this.numbers = [1, 2, 3, 4, 5];\n        this.sum = new Subject[\"Subject\"]();\n        this.calculation = {};\n        this.showSum = false;\n    }\n    RxJsBuffering.prototype.add = function (number) {\n        this.sum.next(number);\n    };\n    RxJsBuffering.prototype.ngOnInit = function () {\n        var _this = this;\n        this.series = this.sum\n            .asObservable()\n            .do(function (a) { return _this.showSum = false; })\n            .bufferCount(3)\n            .subscribe(function (res) {\n            _this.calculation = { sum: res.reduce(function (a, b) { return a + b; }) };\n            _this.showSum = true;\n        });\n    };\n    return RxJsBuffering;\n}());\n\n\n// CONCATENATED MODULE: ./components/rxjs-buffering/rxjs-buffering.ngfactory.js\n\n\n\nvar styles_RxJsBuffering = [];\nvar RenderType_RxJsBuffering = core[\"_13\" /* ɵcrt */]({ encapsulation: 2, styles: styles_RxJsBuffering, data: {} });\n\nfunction View_RxJsBuffering_1(_l) { return core[\"_37\" /* ɵvid */](0, [(_l()(), core[\"_15\" /* ɵeld */](0, 0, null, null, 1, \"div\", [[\"class\", \"box\"]], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.add(_v.context.$implicit) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_35\" /* ɵted */](1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.context.$implicit; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_RxJsBuffering_2(_l) { return core[\"_37\" /* ɵvid */](0, [(_l()(), core[\"_15\" /* ɵeld */](0, 0, null, null, 1, \"div\", [[\"class\", \"sum\"]], null, null, null, null, null)), (_l()(), core[\"_35\" /* ɵted */](1, null, [\"SUM: \", \"\"]))], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.calculation.sum; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_RxJsBuffering_0(_l) { return core[\"_37\" /* ɵvid */](0, [(_l()(), core[\"_15\" /* ɵeld */](0, 0, null, null, 1, \"h3\", [], null, null, null, null, null)), (_l()(), core[\"_35\" /* ɵted */](-1, null, [\"Click three numbers to add\"])), (_l()(), core[\"_10\" /* ɵand */](16777216, null, null, 1, null, View_RxJsBuffering_1)), core[\"_14\" /* ɵdid */](3, 802816, null, 0, common[\"j\" /* NgForOf */], [core[\"Y\" /* ViewContainerRef */], core[\"V\" /* TemplateRef */], core[\"y\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_10\" /* ɵand */](16777216, null, null, 1, null, View_RxJsBuffering_2)), core[\"_14\" /* ɵdid */](5, 16384, null, 0, common[\"k\" /* NgIf */], [core[\"Y\" /* ViewContainerRef */], core[\"V\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.numbers; _ck(_v, 3, 0, currVal_0); var currVal_1 = _co.showSum; _ck(_v, 5, 0, currVal_1); }, null); }\nfunction View_RxJsBuffering_Host_0(_l) { return core[\"_37\" /* ɵvid */](0, [(_l()(), core[\"_15\" /* ɵeld */](0, 0, null, null, 1, \"ng-component\", [], null, null, null, View_RxJsBuffering_0, RenderType_RxJsBuffering)), core[\"_14\" /* ɵdid */](1, 114688, null, 0, rxjs_buffering_RxJsBuffering, [], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar RxJsBufferingNgFactory = core[\"_11\" /* ɵccf */](\"ng-component\", rxjs_buffering_RxJsBuffering, View_RxJsBuffering_Host_0, {}, {}, []);\n\n\n// EXTERNAL MODULE: ./node_modules/@angular/router/esm5/router.js\nvar router = __webpack_require__(17);\n\n// CONCATENATED MODULE: ./app-lazy/lazy-modules/rxjs-buffering.module.ngfactory.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RxJsBufferingModuleNgFactory\", function() { return RxJsBufferingModuleNgFactory; });\n\n\n\n\n\n\nvar RxJsBufferingModuleNgFactory = core[\"_12\" /* ɵcmf */](RxJsBufferingModule, [], function (_l) { return core[\"_25\" /* ɵmod */]([core[\"_26\" /* ɵmpd */](512, core[\"k\" /* ComponentFactoryResolver */], core[\"_8\" /* ɵCodegenComponentFactoryResolver */], [[8, [RxJsBufferingNgFactory]], [3, core[\"k\" /* ComponentFactoryResolver */]], core[\"E\" /* NgModuleRef */]]), core[\"_26\" /* ɵmpd */](4608, common[\"m\" /* NgLocalization */], common[\"l\" /* NgLocaleLocalization */], [core[\"A\" /* LOCALE_ID */], [2, common[\"t\" /* ɵa */]]]), core[\"_26\" /* ɵmpd */](512, common[\"c\" /* CommonModule */], common[\"c\" /* CommonModule */], []), core[\"_26\" /* ɵmpd */](512, router[\"m\" /* RouterModule */], router[\"m\" /* RouterModule */], [[2, router[\"r\" /* ɵa */]], [2, router[\"k\" /* Router */]]]), core[\"_26\" /* ɵmpd */](512, RxJsBufferingModule, RxJsBufferingModule, []), core[\"_26\" /* ɵmpd */](1024, router[\"i\" /* ROUTES */], function () { return [[{ path: \"\", component: rxjs_buffering_RxJsBuffering }]]; }, [])]); });\n\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 2.dist/bundle-webpack-lazy-loading.js","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar bufferCount_1 = require('../../operator/bufferCount');\nObservable_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount;\n//# sourceMappingURL=bufferCount.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/bufferCount.js\n// module id = 102\n// module chunks = 2 4","\"use strict\";\nvar bufferCount_1 = require('../operators/bufferCount');\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) { startBufferEvery = null; }\n    return bufferCount_1.bufferCount(bufferSize, startBufferEvery)(this);\n}\nexports.bufferCount = bufferCount;\n//# sourceMappingURL=bufferCount.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/bufferCount.js\n// module id = 103\n// module chunks = 2 4","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) { startBufferEvery = null; }\n    return function bufferCountOperatorFunction(source) {\n        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n    };\n}\nexports.bufferCount = bufferCount;\nvar BufferCountOperator = (function () {\n    function BufferCountOperator(bufferSize, startBufferEvery) {\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        if (!startBufferEvery || bufferSize === startBufferEvery) {\n            this.subscriberClass = BufferCountSubscriber;\n        }\n        else {\n            this.subscriberClass = BufferSkipCountSubscriber;\n        }\n    }\n    BufferCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n    };\n    return BufferCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferCountSubscriber = (function (_super) {\n    __extends(BufferCountSubscriber, _super);\n    function BufferCountSubscriber(destination, bufferSize) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.buffer = [];\n    }\n    BufferCountSubscriber.prototype._next = function (value) {\n        var buffer = this.buffer;\n        buffer.push(value);\n        if (buffer.length == this.bufferSize) {\n            this.destination.next(buffer);\n            this.buffer = [];\n        }\n    };\n    BufferCountSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer.length > 0) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferCountSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSkipCountSubscriber = (function (_super) {\n    __extends(BufferSkipCountSubscriber, _super);\n    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        this.buffers = [];\n        this.count = 0;\n    }\n    BufferSkipCountSubscriber.prototype._next = function (value) {\n        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;\n        this.count++;\n        if (count % startBufferEvery === 0) {\n            buffers.push([]);\n        }\n        for (var i = buffers.length; i--;) {\n            var buffer = buffers[i];\n            buffer.push(value);\n            if (buffer.length === bufferSize) {\n                buffers.splice(i, 1);\n                this.destination.next(buffer);\n            }\n        }\n    };\n    BufferSkipCountSubscriber.prototype._complete = function () {\n        var _a = this, buffers = _a.buffers, destination = _a.destination;\n        while (buffers.length > 0) {\n            var buffer = buffers.shift();\n            if (buffer.length > 0) {\n                destination.next(buffer);\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferSkipCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=bufferCount.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/bufferCount.js\n// module id = 104\n// module chunks = 2 4","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar do_1 = require('../../operator/do');\nObservable_1.Observable.prototype.do = do_1._do;\nObservable_1.Observable.prototype._do = do_1._do;\n//# sourceMappingURL=do.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/do.js\n// module id = 105\n// module chunks = 1 2","\"use strict\";\nvar tap_1 = require('../operators/tap');\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\nfunction _do(nextOrObserver, error, complete) {\n    return tap_1.tap(nextOrObserver, error, complete)(this);\n}\nexports._do = _do;\n//# sourceMappingURL=do.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/do.js\n// module id = 106\n// module chunks = 1 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nfunction tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nexports.tap = tap;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=tap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/tap.js\n// module id = 107\n// module chunks = 1 2","import * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"./rxjs-buffering\";\nvar styles_RxJsBuffering = [];\nvar RenderType_RxJsBuffering = i0.ɵcrt({ encapsulation: 2, styles: styles_RxJsBuffering, data: {} });\nexport { RenderType_RxJsBuffering as RenderType_RxJsBuffering };\nfunction View_RxJsBuffering_1(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"div\", [[\"class\", \"box\"]], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.add(_v.context.$implicit) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ɵted(1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.context.$implicit; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_RxJsBuffering_2(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"div\", [[\"class\", \"sum\"]], null, null, null, null, null)), (_l()(), i0.ɵted(1, null, [\"SUM: \", \"\"]))], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.calculation.sum; _ck(_v, 1, 0, currVal_0); }); }\nexport function View_RxJsBuffering_0(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"h3\", [], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"Click three numbers to add\"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_RxJsBuffering_1)), i0.ɵdid(3, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_RxJsBuffering_2)), i0.ɵdid(5, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.numbers; _ck(_v, 3, 0, currVal_0); var currVal_1 = _co.showSum; _ck(_v, 5, 0, currVal_1); }, null); }\nexport function View_RxJsBuffering_Host_0(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"ng-component\", [], null, null, null, View_RxJsBuffering_0, RenderType_RxJsBuffering)), i0.ɵdid(1, 114688, null, 0, i2.RxJsBuffering, [], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar RxJsBufferingNgFactory = i0.ɵccf(\"ng-component\", i2.RxJsBuffering, View_RxJsBuffering_Host_0, {}, {}, []);\nexport { RxJsBufferingNgFactory as RxJsBufferingNgFactory };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/rxjs-buffering/rxjs-buffering.ngfactory.js\n// module id = null\n// module chunks = ","import 'rxjs/add/operator/do';\nimport 'rxjs/add/operator/bufferCount';\nvar RxJsBufferingModule = (function () {\n    function RxJsBufferingModule() {\n    }\n    return RxJsBufferingModule;\n}());\nexport { RxJsBufferingModule };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app-lazy/lazy-modules/rxjs-buffering.module.ts\n// module id = null\n// module chunks = ","import { Subject } from 'rxjs/Subject';\nvar RxJsBuffering = (function () {\n    function RxJsBuffering() {\n        this.numbers = [1, 2, 3, 4, 5];\n        this.sum = new Subject();\n        this.calculation = {};\n        this.showSum = false;\n    }\n    RxJsBuffering.prototype.add = function (number) {\n        this.sum.next(number);\n    };\n    RxJsBuffering.prototype.ngOnInit = function () {\n        var _this = this;\n        this.series = this.sum\n            .asObservable()\n            .do(function (a) { return _this.showSum = false; })\n            .bufferCount(3)\n            .subscribe(function (res) {\n            _this.calculation = { sum: res.reduce(function (a, b) { return a + b; }) };\n            _this.showSum = true;\n        });\n    };\n    return RxJsBuffering;\n}());\nexport { RxJsBuffering };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/rxjs-buffering/rxjs-buffering.ts\n// module id = null\n// module chunks = ","import * as i0 from \"@angular/core\";\nimport * as i1 from \"./rxjs-buffering.module\";\nimport * as i2 from \"../../components/rxjs-buffering/rxjs-buffering.ngfactory\";\nimport * as i3 from \"@angular/common\";\nimport * as i4 from \"@angular/router\";\nimport * as i5 from \"../../components/rxjs-buffering/rxjs-buffering\";\nvar RxJsBufferingModuleNgFactory = i0.ɵcmf(i1.RxJsBufferingModule, [], function (_l) { return i0.ɵmod([i0.ɵmpd(512, i0.ComponentFactoryResolver, i0.ɵCodegenComponentFactoryResolver, [[8, [i2.RxJsBufferingNgFactory]], [3, i0.ComponentFactoryResolver], i0.NgModuleRef]), i0.ɵmpd(4608, i3.NgLocalization, i3.NgLocaleLocalization, [i0.LOCALE_ID, [2, i3.ɵa]]), i0.ɵmpd(512, i3.CommonModule, i3.CommonModule, []), i0.ɵmpd(512, i4.RouterModule, i4.RouterModule, [[2, i4.ɵa], [2, i4.Router]]), i0.ɵmpd(512, i1.RxJsBufferingModule, i1.RxJsBufferingModule, []), i0.ɵmpd(1024, i4.ROUTES, function () { return [[{ path: \"\", component: i5.RxJsBuffering }]]; }, [])]); });\nexport { RxJsBufferingModuleNgFactory as RxJsBufferingModuleNgFactory };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app-lazy/lazy-modules/rxjs-buffering.module.ngfactory.js\n// module id = null\n// module chunks = "],"sourceRoot":""}